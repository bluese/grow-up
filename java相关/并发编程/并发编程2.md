## Lock体系  
### lock和AbstractQueuedSynchronizer(AQS)
lock与syncronized有一样的锁功能，但不会自动的释放锁，必须调用unlock()手动释放  

     AQS底层通过cas来保障同一时刻只有一个线程抢到锁，没有抢到锁的线程会放入链表实现的阻塞队列中,同时调用LockSupport.park()将线程挂起。释放锁后，会把阻塞队列中最早插入的线程拿出来，调用unPark唤醒

     AQS提供了一个由volatile修饰的，采用cas方式修改的int类型的变量status。 并且维护了一个双向链表，有head，有tail，并且每个节点都是一个Node
    
同时为了实现线程挂起的能力，aqs内部提供了condition的对象
    
    和syncronized类似，condition提供await、signal、signalAll来阻塞和唤醒线程


LockSupport:park()、unpark()实现原理  

    底层park的语义就是等待获取一个许可，unpark是颁发一个许可。先调用unpark颁发许可时，在调用park时，可以立马激活。
    底层就是线程级别的一个parker对象中的counter属性

可重入锁的原理

    本质上是维护了一个计数器，每当获取锁的时候，判断当前持有锁的线程是不是自己，如果是自己就把计数器+1.  释放锁的时候，把计数器-1，直到计数器为0，才真正把锁释放

公平锁与非公平锁
    
    qps中提供了公平锁和非公平锁的实现，非公平锁一上来就会去尝试抢锁，抢不到才加入阻塞队列。公平锁一上来先看阻塞队列中有没有阻塞的线程，先去排队等待。
    非公平锁效率更高一些，因为少了线程被挂起的概率

### ReentrantReadWirteLock 

    适用于读多写少的场景。读读之间锁不互斥的，读读、读写间互斥。

    实现原理：
        内部基于AQS实现，利用status变量来进行读写锁并发的控制，高16位用于读锁、低16为用于写入。因为status变量是32bit位的int
        QAS是可重入的，其中写锁和reentrantlock一样，对status低16位进行+1强锁
        读锁是对高16位的status进行操作，因为读锁是不互斥的，所以为了记录每一个读锁重入的次数，还会给每个线程分配一个ThreadLocal来记录重入次数
        写锁饥饿问题：读锁是共享的，如果有大量的线程来获取读锁，此时针对于有写数据的线程，怎么防止一直被阻塞。 读锁拿到资源后，再有读线程来获取读锁时，先进去aqs队列，只有队列前面没有获取写锁的线程，才能获取到读锁资源，只会让写锁之前的读线程拿到锁资源